import { client, poll } from '../../apiClient/client';
import { Log } from '../../utils/Log';

export default (testEnv, testResult, testName = 'undefined') => {
  describe('UpdateContentSource', () => {
    const contentTypes = {
      App: 'AppContentSource',
      Input: 'InputContentSource',
      Playlist: 'PlaylistContentSource',
      Bookmark: 'BookmarkContentSource',
    };

    let targetContent; //this variable will be used with switch statements 
    let currentContentType;

    //Change the input source to a random input
    it('Changes the content source of a display', async () => {
      testEnv.log.Info('Running test: ' + testName);
      const display = testEnv.getDisplay();
      const currentContent = display.contentSource;
      currentContentType = currentContent.__typename;
      console.log('Current content:' + currentContent.__typename);

      //Excluding current content type
      let content = (await client.getDisplay({ displayId: display.id })).display.contentSource
        .available;

      if (content && content.length > 0) {
        if (content.includes(currentContent)) //The includes function is an array method in JavaScript that checks whether an array includes a particular element. In this context, it is used to check if the array content contains the value of currentContent. If the value is present, the condition evaluates to true.
        { 
          content.splice(content.indexOf(currentContent), 1); //deleting
          //The splice function is another array method in JavaScript. It is used to change the contents of an array by removing or replacing existing elements and/or adding new elements in place.
          //indexOf () will remove the current content and here  1: This is the number of elements to be removed starting from the index found by indexOf.
          //content.splice(content.indexOf(currentContent), 1) removes one element from the array, specifically the element with the value currentContent. This effectively deletes the currentContent from the content array if it is present.
          //the code checks if the currentContent is present in the content array. If it is, it removes that element from the array using splice. This is a way to filter out the currentContent from the array.
        }

        //Filter out MEDIA PLAYER and BROWSER
        content = content.filter((source) => {
          //content.filter((source) => {: The filter method is used on arrays in JavaScript to create a new array with elements that pass a certain condition. In this case, it's filtering the content array based on the condition specified in the callback function.
          //if (source.__typename === 'InputContentSource') {: Checks if the __typename property of the current source object is equal to the string 'InputContentSource'.
          //return source.source !== 'MEDIA PLAYER' && source.source !== 'BROWSER';: If the __typename is 'InputContentSource', it further checks if the source property of the source object is not equal to 'MEDIA PLAYER' and 'BROWSER'. If both conditions are true, the element passes the filter.
          //return true;: If the __typename is not 'InputContentSource', the element automatically passes the filter.


          if (source.__typename === 'InputContentSource') {
            return source.source !== 'MEDIA PLAYER' && source.source !== 'BROWSER';
          }
          return true;
        });
        //Math.random(): This method returns a floating-point number between 0 (inclusive) and 1 (exclusive). In other words, it generates a random decimal number in the range [0, 1).  
        //This line uses the Math object in JavaScript to generate a random number
        //* content.length: This part multiplies the random decimal number generated by Math.random() with the length of the content array. This effectively scales the random number to fit within the range of array indices.
        //Math.floor(...): Finally, Math.floor() is used to round down the result of the multiplication to the nearest integer. This ensures that the result is a whole number, which can be used as a valid index for an array.
  
        const random = Math.floor(Math.random() * content.length);
        targetContent = content[random];
        //this line selects a random content source from the filtered list and assigns it to targetContent.

      } else {
        //If selecting a random input somehow fails, fall back to HDMI as default
        targetContent.source = 'HDMI';
        targetContent.__typename = contentTypes.Input;//object type will be accessing above input 
        //Also, in this fallback scenario, it sets the __typename property of targetContent to a value defined elsewhere in the code, presumably stored in the contentTypes.Input variable.
      }

      console.log(content);
      console.log('Target content:' + targetContent.__typename);

      switch (targetContent.__typename) {
        case contentTypes.App:
          const appResponse = await client.UpdateAppContentSource({
            input: {
              displayIds: display.id,
              applicationId: targetContent.applicationId,
              label: targetContent.label,
            },
          });
          // we are validating things using jest env 
          expect(
            appResponse.displayBulkUpdateAppContentSource.displays[0].contentSource.current.desired //this is from graphql
              .__typename,
          ).toEqual(targetContent.__typename);
          break;
        case contentTypes.Input:
          const inputResponse = await client.UpdateInputContentSource({
            input: { displayIds: display.id, source: targetContent.source },
          });
          expect(
            inputResponse.displayBulkUpdateInputContentSource.displays[0].contentSource.current
              .desired.__typename,
          ).toEqual(targetContent.__typename);
          break;
        case contentTypes.Playlist:
          const playlistResponse = await client.UpdatePlaylistContentSource({
            input: { displayIds: display.id, playlistId: targetContent.playlistId },
          });
          expect(
            playlistResponse.displayBulkUpdatePlaylistContentSource.displays[0].contentSource
              .current.desired.__typename,
          ).toEqual(targetContent.__typename);
          break;
        case contentTypes.Bookmark:
          const bookmarkResponse = await client.UpdateBookmarkContentSource({
            input: { displayIds: display.id, index: targetContent.index },
          });
          expect(
            bookmarkResponse.displayBulkUpdateBookmarkContentSource.displays[0].contentSource
              .current.desired.__typename,
          ).toEqual(targetContent.__typename);
          break;
        default:
          const defaultResponse = await client.UpdateInputContentSource({
            input: { displayIds: display.id, source: targetContent.source },
          });
          expect(
            defaultResponse.displayBulkUpdateInputContentSource.displays[0].contentSource.current
              .desired.__typename,
          ).toEqual(contentTypes.Input);
          break;
      }
    });

    //Verify the current input is the desired input
    it('Validates the content source of a display', async () => {
      testEnv.log.Info('Validating test: ' + testName);
      testResult.test = testName;
      testResult.expectedResult = targetContent;
      const display = testEnv.getDisplay();

      const response = await poll(
        () => client.getDisplay({ displayId: testEnv.getDisplay().id }),
        (response) => {
          return response.display.contentSource.current.desired === null;
        },
      );

      testResult.actualResult = response.display.contentSource.current.reported;
      //Null as response invalidates test result
      if (testResult.actualResult == null) {
        return;
      }
      testEnv.log.Response(testName, JSON.stringify(response));
      expect(testResult.actualResult).toEqual(testResult.expectedResult);
      expect(response.display.presence.connected).toEqual(true);
    });
  });
};
